<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Maximal Itemset Mining · RuleMiner.jl</title><meta name="title" content="Maximal Itemset Mining · RuleMiner.jl"/><meta property="og:title" content="Maximal Itemset Mining · RuleMiner.jl"/><meta property="twitter:title" content="Maximal Itemset Mining · RuleMiner.jl"/><meta name="description" content="Documentation for RuleMiner.jl."/><meta property="og:description" content="Documentation for RuleMiner.jl."/><meta property="twitter:description" content="Documentation for RuleMiner.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="RuleMiner.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RuleMiner.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../association_rules/">Association Rule Mining</a></li><li><span class="tocitem">Itemset Mining</span><ul><li><a class="tocitem" href="../frequent_itemsets/">Frequent Itemset Mining</a></li><li><a class="tocitem" href="../closed_itemsets/">Closed Itemset Mining</a></li><li class="is-active"><a class="tocitem" href>Maximal Itemset Mining</a><ul class="internal"><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Formal-Definition"><span>Formal Definition</span></a></li><li><a class="tocitem" href="#Frequent-Itemset-Recovery"><span>Frequent Itemset Recovery</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../transactions/">Transactions Objects</a></li><li><a class="tocitem" href="../fptree/">FP Tree Objects</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Itemset Mining</a></li><li class="is-active"><a href>Maximal Itemset Mining</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Maximal Itemset Mining</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JaredSchwartz/RuleMiner.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JaredSchwartz/RuleMiner.jl/blob/main/docs/src/maximal_itemsets.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Maximal-Itemset-Mining"><a class="docs-heading-anchor" href="#Maximal-Itemset-Mining">Maximal Itemset Mining</a><a id="Maximal-Itemset-Mining-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Itemset-Mining" title="Permalink"></a></h1><p><img src="../assets/maximal.png" alt="Diagram showing maximal itemsets as a subset of closed itemsets which are a subset of frequent itemsets"/></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Maximal itemset mining is a set of techniques focused on discovering maximal itemsets in a transactional dataset. A maximal itemset is one which appears frequently in the data (above the minimum support threshold) and which is not a subset of any other frequent itemset. </p><p>In other words, maximal itemsets are the largest possible combinations in the dataset of the items that meet a specified frequency threshold. They are a subset of closed itemsets, which in turn are a subset of all frequent itemsets.</p><p>The key advantage of mining maximal itemsets is its compact representation of all frequent patterns in the data. By identifying only the maximal frequent itemsets, the number of patterns generated is significantly reduced compared to frequent itemset mining. This approach is particularly valuable when dealing with high-dimensional data or datasets with long transactions.</p><h2 id="Formal-Definition"><a class="docs-heading-anchor" href="#Formal-Definition">Formal Definition</a><a id="Formal-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-Definition" title="Permalink"></a></h2><p>Let:</p><ul><li><span>$I$</span> be the set of all items in the dataset</li><li><span>$X$</span> be an itemset, where <span>$X \subseteq I$</span></li><li><span>$D$</span> be the set of all transactions in the dataset</li><li><span>$\sigma(X)$</span> be the support of itemset <span>$X$</span> in <span>$D$</span></li><li><span>$\sigma_{min}$</span> be the minimum support threshold</li></ul><p>Then, an itemset <span>$X$</span> is a maximal frequent itemset if and only if: 1.	The support of <span>$X$</span> is greater than or equal to the minimum support threshold: </p><p class="math-container">\[\sigma(X) \geq \sigma_{min}\]</p><p>2.	There does not exist a superset <span>$Y$</span> of <span>$X$</span> such that <span>$Y$</span> is also frequent: </p><p class="math-container">\[\nexists Y \supset X : \sigma(Y) \geq \sigma_{min}\]</p><p>Thus, <span>$MFI$</span>, the set of all maximal frequent itemsets in <span>$I$</span> can be expressed as:</p><p class="math-container">\[MFI = {X \mid X \subseteq I \wedge \sigma(X) \geq \sigma_{min} \wedge \nexists Y \supset X : \sigma(Y) \geq \sigma_{min}}\]</p><h2 id="Frequent-Itemset-Recovery"><a class="docs-heading-anchor" href="#Frequent-Itemset-Recovery">Frequent Itemset Recovery</a><a id="Frequent-Itemset-Recovery-1"></a><a class="docs-heading-anchor-permalink" href="#Frequent-Itemset-Recovery" title="Permalink"></a></h2><p>Maximal itemsets can be used to recover all frequent itemsets by generating combinations from the mined itemset. However, unlike with closed itemsets, recovering the support of the frequent combinations is not possible.</p><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><h3 id="FPMax"><a class="docs-heading-anchor" href="#FPMax">FPMax</a><a id="FPMax-1"></a><a class="docs-heading-anchor-permalink" href="#FPMax" title="Permalink"></a></h3><p>The <code>fpmax</code> function implements the FPMax ([F]requent [P]attern Max) algorithm for mining closed itemsets. This algorithm, proposed by Gösta Grahne and Jianfei Zhu in 2005, builds on the FP-Growth alogrithm by mining FP trees to discover maximal itemsets in a dataset. It inherits many of the advantages of FP-Growth when it comes to dense datasets.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RuleMiner.fpmax-Tuple{Transactions, Union{Float64, Int64}}" href="#RuleMiner.fpmax-Tuple{Transactions, Union{Float64, Int64}}"><code>RuleMiner.fpmax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fpmax(data::Union{Transactions,FPTree}, min_support::Union{Int,Float64})::DataFrame</code></pre><p>Identify maximal frequent itemsets in a transactional dataset or an FP-tree with the FPMax algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>data::Union{Transactions,FPTree}</code>: Either a <code>Transactions</code> object containing the dataset to mine, or a pre-constructed <code>FPTree</code> object.</li><li><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents  the absolute support. If a <code>Float64</code>, it represents relative support.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns:<ul><li><code>Itemset</code>: The items in the maximal frequent itemset.</li><li><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</li><li><code>N</code>: The absolute support count of the itemset.</li><li><code>Length</code>: The number of items in the itemset.</li></ul></li></ul><p><strong>Description</strong></p><p>The FPMax algorithm is an extension of FP-Growth with additional pruning techniques  to focus on mining maximal itemsets. The algorithm operates in three main phases:</p><ol><li><p>FP-tree Construction: Builds a compact representation of the dataset, organizing items  by their frequency to allow efficient mining. This step is skipped if an FPTree is provided.</p></li><li><p>Recursive Tree Traversal: </p><ul><li>Processes itemsets from least frequent to most frequent.</li><li>For each item, creates a conditional FP-tree and recursively mines it.</li><li>Uses a depth-first search strategy, exploring longer itemsets before shorter ones.</li><li>Employs pruning techniques to avoid generating non-maximal itemsets.</li><li>Adds an itemset to the candidate set when no frequent superset exists.</li></ul></li><li><p>Maximality Checking: After the recursive traversal, filters the candidate set to ensure  only truly maximal itemsets are included in the final output.</p></li></ol><p>FPMax is particularly efficient for datasets with long transactions or sparse frequent itemsets,  as it can significantly reduce the number of generated itemsets compared to algorithms that  find all frequent itemsets.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Using a Transactions object
txns = Txns(&quot;transactions.txt&quot;, &#39; &#39;)
result = fpmax(txns, 0.05)  # Find maximal frequent itemsets with 5% minimum support

# Using a pre-constructed FPTree
tree = FPTree(txns, 5000)  # Construct FP-tree with minimum support of 5000
result = fpmax(tree, 6000)  # Find maximal frequent itemsets with minimum support of 6000</code></pre><p><strong>References</strong></p><p>Grahne, Gösta, and Jianfei Zhu. &quot;Fast Algorithms for Frequent Itemset Mining Using FP-Trees.&quot;  IEEE Transactions on Knowledge and Data Engineering 17, no. 10 (October 2005): 1347–62.  https://doi.org/10.1109/TKDE.2005.166.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JaredSchwartz/RuleMiner.jl/blob/adf02097c349f0cfe06ab732555930389d166fdc/src/itemsets/maximal/fpmax.jl#L25-L78">source</a></section></article><h3 id="GenMax"><a class="docs-heading-anchor" href="#GenMax">GenMax</a><a id="GenMax-1"></a><a class="docs-heading-anchor-permalink" href="#GenMax" title="Permalink"></a></h3><p>The <code>genmax</code> function implements the GenMax algorithm for mining closed itemsets. This algorithm, proposed by Karam Gouda and Mohammad Zaki in 2005, utilizes a technique called progressive focusing to reduce the search space for maximal itemset mining.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RuleMiner.genmax-Tuple{Transactions, Union{Float64, Int64}}" href="#RuleMiner.genmax-Tuple{Transactions, Union{Float64, Int64}}"><code>RuleMiner.genmax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">genmax(txns::Transactions, min_support::Union{Int,Float64})::DataFrame</code></pre><p>Identify maximal frequent itemsets in a transactional dataset with the GenMax algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</li><li><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents  the absolute support. If a <code>Float64</code>, it represents relative support.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns:<ul><li><code>Itemset</code>: The items in the maximal frequent itemset.</li><li><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</li><li><code>N</code>: The absolute support count of the itemset.</li><li><code>Length</code>: The number of items in the itemset.</li></ul></li></ul><p><strong>Description</strong></p><p>The GenMax algorithm finds maximal frequent itemsets, which are frequent itemsets that are not  proper subsets of any other frequent itemset. It uses a depth-first search strategy with  pruning techniques like progressive focusing to discover these itemsets.</p><p>The algorithm proceeds in two main phases:</p><ol><li>Candidate Generation: Uses a depth-first search to generate candidate maximal frequent itemsets.</li><li>Maximality Checking: Ensures that only truly maximal itemsets are retained in the final output.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">txns = Txns(&quot;transactions.txt&quot;, &#39; &#39;)

# Find maximal frequent itemsets with 5% minimum support
result = genmax(txns, 0.05)

# Find maximal frequent itemsets with minimum 5,000 transactions
result = genmax(txns, 5_000)</code></pre><p><strong>References</strong></p><p>Gouda, Karam, and Mohammed J. Zaki. “GenMax: An Efficient Algorithm for Mining Maximal Frequent Itemsets.” Data Mining and Knowledge Discovery 11, no. 3 (November 1, 2005): 223–42. https://doi.org/10.1007/s10618-005-0002-x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JaredSchwartz/RuleMiner.jl/blob/adf02097c349f0cfe06ab732555930389d166fdc/src/itemsets/maximal/genmax.jl#L25-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../closed_itemsets/">« Closed Itemset Mining</a><a class="docs-footer-nextpage" href="../transactions/">Transactions Objects »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 29 September 2024 01:11">Sunday 29 September 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

import{_ as p,C as h,c as r,o as k,j as i,a as e,az as n,G as a,w as l}from"./chunks/framework.BpaTVg5z.js";const P=JSON.parse('{"title":"API Reference","description":"","frontmatter":{},"headers":[],"relativePath":"api_reference.md","filePath":"api_reference.md","lastUpdated":null}'),o={name:"api_reference.md"},d={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"};function v(B,s,_,I,j,q){const t=h("Badge");return k(),r("div",null,[s[60]||(s[60]=i("h1",{id:"API-Reference",tabindex:"-1"},[e("API Reference "),i("a",{class:"header-anchor",href:"#API-Reference","aria-label":'Permalink to "API Reference {#API-Reference}"'},"​")],-1)),s[61]||(s[61]=i("h2",{id:"Association-Rule-Mining",tabindex:"-1"},[e("Association Rule Mining "),i("a",{class:"header-anchor",href:"#Association-Rule-Mining","aria-label":'Permalink to "Association Rule Mining {#Association-Rule-Mining}"'},"​")],-1)),i("details",d,[i("summary",null,[s[0]||(s[0]=i("a",{id:"RuleMiner.apriori-Tuple{Transactions, Union{Float64, Int64}, Float64, Int64}",href:"#RuleMiner.apriori-Tuple{Transactions, Union{Float64, Int64}, Float64, Int64}"},[i("span",{class:"jlbinding"},"RuleMiner.apriori")],-1)),s[1]||(s[1]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[3]||(s[3]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apriori</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    min_confidence</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify association rules in a transactional dataset using the A Priori Algorithm</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li><li><p><code>min_confidence::Float64</code>: The minimum confidence percentage for returned rules.</p></li><li><p><code>max_length::Int</code>: The maximum length of the rules to be generated. Length of 0 searches for all rules.</p></li></ul><p><strong>Returns</strong></p><p>A DataFrame containing the discovered association rules with the following columns:</p><ul><li><p><code>LHS</code>: The left-hand side (antecedent) of the rule.</p></li><li><p><code>RHS</code>: The right-hand side (consequent) of the rule.</p></li><li><p><code>Support</code>: Relative support of the rule.</p></li><li><p><code>Confidence</code>: Confidence of the rule.</p></li><li><p><code>Coverage</code>: Coverage (RHS support) of the rule.</p></li><li><p><code>Lift</code>: Lift of the association rule.</p></li><li><p><code>N</code>: Absolute support of the association rule.</p></li><li><p><code>Length</code>: The number of items in the association rule.</p></li></ul><p><strong>Description</strong></p><p>The Apriori algorithm employs a breadth-first, level-wise search strategy to discover frequent itemsets. It starts by identifying frequent individual items and iteratively builds larger itemsets by combining smaller frequent itemsets. At each iteration, it generates candidate itemsets of size k from itemsets of size k-1, then prunes infrequent candidates and their subsets.</p><p>The algorithm uses the downward closure property, which states that any subset of a frequent itemset must also be frequent. This is the defining pruning technique of A Priori. Once all frequent itemsets up to the specified maximum length are found, the algorithm generates association rules and calculates their support, confidence, and other metrics.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find all rules with 5% min support and max length of 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> apriori</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find rules with with at least 5,000 instances and minimum confidence of 50%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> apriori</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Agrawal, Rakesh, and Ramakrishnan Srikant. “Fast Algorithms for Mining Association Rules in Large Databases.” In Proceedings of the 20th International Conference on Very Large Data Bases, 487–99. VLDB ’94. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1994.</p>`,14)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[2]||(s[2]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/association_rules/apriori.jl#L29-L80",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),s[62]||(s[62]=i("h2",{id:"Itemset-Mining",tabindex:"-1"},[e("Itemset Mining "),i("a",{class:"header-anchor",href:"#Itemset-Mining","aria-label":'Permalink to "Itemset Mining {#Itemset-Mining}"'},"​")],-1)),s[63]||(s[63]=i("h3",{id:"Frequent-Itemset-Mining",tabindex:"-1"},[e("Frequent Itemset Mining "),i("a",{class:"header-anchor",href:"#Frequent-Itemset-Mining","aria-label":'Permalink to "Frequent Itemset Mining {#Frequent-Itemset-Mining}"'},"​")],-1)),i("details",g,[i("summary",null,[s[4]||(s[4]=i("a",{id:"RuleMiner.eclat-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.eclat-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.eclat")],-1)),s[5]||(s[5]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[7]||(s[7]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eclat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Perform frequent itemset mining using the ECLAT (Equivalence CLAss Transformation) algorithm on a transactional dataset.</p><p>ECLAT is an efficient algorithm for discovering frequent itemsets, which are sets of items that frequently occur together in the dataset.</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><p>A DataFrame containing the discovered frequent itemsets with the following columns:</p><ul><li><p><code>Itemset</code>: Vector of item names in the frequent itemset.</p></li><li><p><code>Support</code>: Relative support of the itemset.</p></li><li><p><code>N</code>: Absolute support count of the itemset.</p></li><li><p><code>Length</code>: Number of items in the itemset.</p></li></ul><p><strong>Algorithm Description</strong></p><p>The ECLAT algorithm uses a depth-first search strategy and a vertical database layout to efficiently mine frequent itemsets. It starts by computing the support of individual items, sorts them in descending order of frequency, and then recursively builds larger itemsets. ECLAT&#39;s depth-first approach enables it to quickly identify long frequent itemsets, and it is most efficient for sparse datasets</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find frequent itemsets with 5% minimum support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eclat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eclat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Zaki, Mohammed. “Scalable Algorithms for Association Mining.” Knowledge and Data Engineering, IEEE Transactions On 12 (June 1, 2000): 372–90. <a href="https://doi.org/10.1109/69.846291" target="_blank" rel="noreferrer">https://doi.org/10.1109/69.846291</a>.</p>`,14)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[6]||(s[6]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/frequent/eclat.jl#L6-L45",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),i("details",c,[i("summary",null,[s[8]||(s[8]=i("a",{id:"RuleMiner.fpgrowth-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.fpgrowth-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.fpgrowth")],-1)),s[9]||(s[9]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[11]||(s[11]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fpgrowth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Transactions,FPTree}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify frequent itemsets in a transactional dataset or an FP-tree with the FPGrowth algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::Union{Transactions,FPTree}</code>: Either a <code>Transactions</code> object containing the dataset to mine, or a pre-constructed <code>FPTree</code> object.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>The FPGrowth algorithm is a mining technique that builds a compact summary of the transaction data called an FP-tree. This tree structure summarizes the supports and relationships between items in a way that can be easily traversed and processed to find frequent itemsets. FPGrowth is particularly efficient for datasets with long transactions or sparse frequent itemsets.</p><p>The algorithm operates in two main phases:</p><ol><li><p>FP-tree Construction: Builds a compact representation of the dataset, organizing items by their frequency to allow efficient mining. This step is skipped if an FPTree is provided.</p></li><li><p>Recursive Tree Traversal:</p></li></ol><ul><li><p>Processes itemsets from least frequent to most frequent.</p></li><li><p>For each item, creates a conditional FP-tree and recursively mines it.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a Transactions object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpgrowth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find frequent itemsets with 5% minimum support</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a pre-constructed FPTree</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Construct FP-tree with minimum support of 5000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpgrowth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find frequent itemsets with minimum support of 6000</span></span></code></pre></div><p><strong>References</strong></p><p>Han, Jiawei, Jian Pei, and Yiwen Yin. &quot;Mining Frequent Patterns without Candidate Generation.&quot; SIGMOD Rec. 29, no. 2 (May 16, 2000): 1–12. <a href="https://doi.org/10.1145/335191.335372" target="_blank" rel="noreferrer">https://doi.org/10.1145/335191.335372</a>.</p>`,15)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[10]||(s[10]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/frequent/fpgrowth.jl#L6-L52",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),s[64]||(s[64]=i("h3",{id:"Closed-Itemset-Mining",tabindex:"-1"},[e("Closed Itemset Mining "),i("a",{class:"header-anchor",href:"#Closed-Itemset-Mining","aria-label":'Permalink to "Closed Itemset Mining {#Closed-Itemset-Mining}"'},"​")],-1)),i("details",E,[i("summary",null,[s[12]||(s[12]=i("a",{id:"RuleMiner.charm-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.charm-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.charm")],-1)),s[13]||(s[13]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[15]||(s[15]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">charm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify closed frequent itemsets in a transactional dataset with the CHARM algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>CHARM is an algorithm that builds on the ECLAT algorithm but adds additional closed-ness checking to return only closed itemsets. It uses a depth-first approach, exploring the search space and checking found itemsets against previously discovered itemsets to determine closedness.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with 5% minimum support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> charm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> charm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Zaki, Mohammed, and Ching-Jui Hsiao. “CHARM: An Efficient Algorithm for Closed Itemset Mining.” In Proceedings of the 2002 SIAM International Conference on Data Mining (SDM), 457–73. Proceedings. Society for Industrial and Applied Mathematics, 2002. <a href="https://doi.org/10.1137/1.9781611972726.27" target="_blank" rel="noreferrer">https://doi.org/10.1137/1.9781611972726.27</a>.</p>`,12)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[14]||(s[14]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/closed/charm.jl#L6-L39",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),i("details",u,[i("summary",null,[s[16]||(s[16]=i("a",{id:"RuleMiner.fpclose-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.fpclose-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.fpclose")],-1)),s[17]||(s[17]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[19]||(s[19]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fpclose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Transactions,FPTree}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify closed frequent itemsets in a transactional dataset or an FP-tree with the FPClose algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::Union{Transactions,FPTree}</code>: Either a <code>Transactions</code> object containing the dataset to mine, or a pre-constructed <code>FPTree</code> object.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the closed frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the closed frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>The FPClose algorithm is an extension of FP-Growth with additional pruning techniques to focus on mining closed itemsets. The algorithm operates in two main phases:</p><ol><li><p>FP-tree Construction: Builds a compact representation of the dataset, organizing items by their frequency to allow efficient mining. This step is skipped if an FPTree is provided.</p></li><li><p>Recursive Tree Traversal:</p></li></ol><ul><li><p>Processes itemsets from least frequent to most frequent.</p></li><li><p>For each item, creates a conditional FP-tree and recursively mines it.</p></li><li><p>Uses a depth-first search strategy, exploring longer itemsets before shorter ones.</p></li><li><p>Employs pruning techniques to avoid generating non-closed itemsets.</p></li></ul><p>FPClose is particularly efficient for datasets with long transactions or sparse frequent itemsets, as it can significantly reduce the number of generated itemsets compared to algorithms that find all frequent itemsets.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a Transactions object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpclose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with 5% minimum support</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a pre-constructed FPTree</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Construct FP-tree with minimum support of 5000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpclose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with minimum support of 6000</span></span></code></pre></div><p><strong>References</strong></p><p>Grahne, Gösta, and Jianfei Zhu. &quot;Fast Algorithms for Frequent Itemset Mining Using FP-Trees.&quot; IEEE Transactions on Knowledge and Data Engineering 17, no. 10 (October 2005): 1347–62. <a href="https://doi.org/10.1109/TKDE.2005.166" target="_blank" rel="noreferrer">https://doi.org/10.1109/TKDE.2005.166</a>.</p>`,15)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[18]||(s[18]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/closed/fpclose.jl#L6-L55",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),i("details",y,[i("summary",null,[s[20]||(s[20]=i("a",{id:"RuleMiner.LCM-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.LCM-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.LCM")],-1)),s[21]||(s[21]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[23]||(s[23]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LCM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify closed frequent itemsets in a transactional dataset with the LCM algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>LCM is an algorithm that uses a depth-first search pattern with closed-ness checking to return only closed itemsets. It utilizes two key pruning techniques to avoid redundant mining: prefix-preserving closure extension (PPCE) and progressive database reduction (PDR).</p><ul><li><p>PPCE ensures that each branch will never overlap in the itemsets they explore by enforcing the order of the itemsets. This reduces redunant search space.</p></li><li><p>PDR works with PPCE to remove data from a branch&#39;s dataset once it is determined to be not nescessary.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with 5% minimum support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LCM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LCM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Uno, Takeaki, Tatsuya Asai, Yuzo Uchida, and Hiroki Arimura. “An Efficient Algorithm for Enumerating Closed Patterns in Transaction Databases.” In Discovery Science, edited by Einoshin Suzuki and Setsuo Arikawa, 16–31. Berlin, Heidelberg: Springer, 2004. <a href="https://doi.org/10.1007/978-3-540-30214-8_2" target="_blank" rel="noreferrer">https://doi.org/10.1007/978-3-540-30214-8_2</a>.</p>`,13)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[22]||(s[22]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/closed/lcm.jl#L6-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),i("details",m,[i("summary",null,[s[24]||(s[24]=i("a",{id:"RuleMiner.carpenter-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.carpenter-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.carpenter")],-1)),s[25]||(s[25]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[27]||(s[27]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">carpenter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify closed frequent itemsets in a transactional dataset with the CARPENTER algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>CARPENTER is an algorithm that progressively builds larger itemsets, checking closed-ness at each step with three key pruning strategies:</p><ul><li><p>Itemsets are skipped if they have already been marked as closed on another branch</p></li><li><p>Itemsets are skipped if they do not meet minimum support</p></li><li><p>Itemsets&#39; child itemsets are skipped if they change the support when the new items are added</p></li></ul><p>CARPENTER is specialized for datasets which have few transactions, but many items per transaction and may not be the best choice for other data.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with 5% minimum support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> carpenter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> carpenter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Pan, Feng, Gao Cong, Anthony K. H. Tung, Jiong Yang, and Mohammed J. Zaki. “Carpenter: Finding Closed Patterns in Long Biological Datasets.” In Proceedings of the Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 637–42. KDD ’03. New York, NY, USA: Association for Computing Machinery, 2003. <a href="https://doi.org/10.1145/956750.956832" target="_blank" rel="noreferrer">https://doi.org/10.1145/956750.956832</a>.</p>`,14)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[26]||(s[26]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/closed/carpenter.jl#L6-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),s[65]||(s[65]=i("h3",{id:"Maximal-Itemset-Mining",tabindex:"-1"},[e("Maximal Itemset Mining "),i("a",{class:"header-anchor",href:"#Maximal-Itemset-Mining","aria-label":'Permalink to "Maximal Itemset Mining {#Maximal-Itemset-Mining}"'},"​")],-1)),i("details",F,[i("summary",null,[s[28]||(s[28]=i("a",{id:"RuleMiner.fpmax-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.fpmax-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.fpmax")],-1)),s[29]||(s[29]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[31]||(s[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fpmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Transactions,FPTree}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify maximal frequent itemsets in a transactional dataset or an FP-tree with the FPMax algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::Union{Transactions,FPTree}</code>: Either a <code>Transactions</code> object containing the dataset to mine, or a pre-constructed <code>FPTree</code> object.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>The FPMax algorithm is an extension of FP-Growth with additional pruning techniques to focus on mining maximal itemsets. The algorithm operates in three main phases:</p><ol><li><p>FP-tree Construction: Builds a compact representation of the dataset, organizing items by their frequency to allow efficient mining. This step is skipped if an FPTree is provided.</p></li><li><p>Recursive Tree Traversal:</p></li></ol><ul><li><p>Processes itemsets from least frequent to most frequent.</p></li><li><p>For each item, creates a conditional FP-tree and recursively mines it.</p></li><li><p>Uses a depth-first search strategy, exploring longer itemsets before shorter ones.</p></li><li><p>Employs pruning techniques to avoid generating non-maximal itemsets.</p></li><li><p>Adds an itemset to the candidate set when no frequent superset exists.</p></li></ul><ol start="3"><li>Maximality Checking: After the recursive traversal, filters the candidate set to ensure only truly maximal itemsets are included in the final output.</li></ol><p>FPMax is particularly efficient for datasets with long transactions or sparse frequent itemsets, as it can significantly reduce the number of generated itemsets compared to algorithms that find all frequent itemsets.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a Transactions object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find maximal frequent itemsets with 5% minimum support</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a pre-constructed FPTree</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Construct FP-tree with minimum support of 5000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find maximal frequent itemsets with minimum support of 6000</span></span></code></pre></div><p><strong>References</strong></p><p>Grahne, Gösta, and Jianfei Zhu. &quot;Fast Algorithms for Frequent Itemset Mining Using FP-Trees.&quot; IEEE Transactions on Knowledge and Data Engineering 17, no. 10 (October 2005): 1347–62. <a href="https://doi.org/10.1109/TKDE.2005.166" target="_blank" rel="noreferrer">https://doi.org/10.1109/TKDE.2005.166</a>.</p>`,16)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[30]||(s[30]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/maximal/fpmax.jl#L6-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),i("details",f,[i("summary",null,[s[32]||(s[32]=i("a",{id:"RuleMiner.genmax-Tuple{Transactions, Union{Float64, Int64}}",href:"#RuleMiner.genmax-Tuple{Transactions, Union{Float64, Int64}}"},[i("span",{class:"jlbinding"},"RuleMiner.genmax")],-1)),s[33]||(s[33]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">genmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Identify maximal frequent itemsets in a transactional dataset with the GenMax algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>txns::Transactions</code>: A <code>Transactions</code> object containing the dataset to mine.</p></li><li><p><code>min_support::Union{Int,Float64}</code>: The minimum support threshold. If an <code>Int</code>, it represents the absolute support. If a <code>Float64</code>, it represents relative support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>The GenMax algorithm finds maximal frequent itemsets, which are frequent itemsets that are not proper subsets of any other frequent itemset. It uses a depth-first search strategy with pruning techniques like progressive focusing to discover these itemsets.</p><p>The algorithm proceeds in two main phases:</p><ol><li><p>Candidate Generation: Uses a depth-first search to generate candidate maximal frequent itemsets.</p></li><li><p>Maximality Checking: Ensures that only truly maximal itemsets are retained in the final output.</p></li></ol><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find maximal frequent itemsets with 5% minimum support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> genmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find maximal frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> genmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Gouda, Karam, and Mohammed J. Zaki. “GenMax: An Efficient Algorithm for Mining Maximal Frequent Itemsets.” Data Mining and Knowledge Discovery 11, no. 3 (November 1, 2005): 223–42. <a href="https://doi.org/10.1007/s10618-005-0002-x" target="_blank" rel="noreferrer">https://doi.org/10.1007/s10618-005-0002-x</a>.</p>`,14)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[34]||(s[34]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/maximal/genmax.jl#L6-L45",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),s[66]||(s[66]=i("h3",{id:"Frequent-Itemset-Recovery",tabindex:"-1"},[e("Frequent Itemset Recovery "),i("a",{class:"header-anchor",href:"#Frequent-Itemset-Recovery","aria-label":'Permalink to "Frequent Itemset Recovery {#Frequent-Itemset-Recovery}"'},"​")],-1)),i("details",C,[i("summary",null,[s[36]||(s[36]=i("a",{id:"RuleMiner.recover_closed-Tuple{DataFrame, Int64}",href:"#RuleMiner.recover_closed-Tuple{DataFrame, Int64}"},[i("span",{class:"jlbinding"},"RuleMiner.recover_closed")],-1)),s[37]||(s[37]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[39]||(s[39]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">recover_closed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Recover frequent itemsets from a DataFrame of closed itemsets.</p><p><strong>Arguments</strong></p><ul><li><p><code>df::DataFrame</code>: A DataFrame containing the closed frequent itemsets, with columns:</p><ul><li><p><code>Itemset</code>: The items in the closed frequent itemset.</p></li><li><p><code>Support</code>: The relative support of the itemset as a proportion of total transactions.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li><li><p><code>min_n::Int</code>: The minimum support threshold for the rules. This is the absolute (integer) support.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing all frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the frequent itemset.</p></li><li><p><code>N</code>: The absolute support count of the itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>This function recovers all frequent itemsets from a set of closed itemsets. It generates all possible subsets of the closed itemsets and calculates their supports based on the smallest containing closed itemset.</p><p>The function works as follows:</p><ol><li><p>It filters the input DataFrame to only include closed sets above the minimum support.</p></li><li><p>For each length k from 1 to the maximum itemset length: a. It generates all k-subsets of the closed itemsets. b. For each subset, it finds the smallest closed itemset containing it. c. It assigns the support of the smallest containing closed itemset to the subset.</p></li><li><p>It combines all frequent itemsets and their supports into a result DataFrame.</p></li></ol><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find closed frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">closed_sets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpclose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Recover frequent itemsets from the closed itemsets</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">frequent_sets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> recover_closed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(closed_sets, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>References</strong></p><p>Pasquier, Nicolas, Yves Bastide, Rafik Taouil, and Lotfi Lakhal. &quot;Efficient Mining of Association Rules Using Closed Itemset Lattices.&quot; Information Systems 24, no. 1 (March 1, 1999): 25–46. <a href="https://doi.org/10.1016/S0306-4379(99)00003-4" target="_blank" rel="noreferrer">https://doi.org/10.1016/S0306-4379(99)00003-4</a>.</p>`,14)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[38]||(s[38]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/frequent/recovery.jl#L6-L51",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),i("details",b,[i("summary",null,[s[40]||(s[40]=i("a",{id:"RuleMiner.recover_maximal-Tuple{DataFrame}",href:"#RuleMiner.recover_maximal-Tuple{DataFrame}"},[i("span",{class:"jlbinding"},"RuleMiner.recover_maximal")],-1)),s[41]||(s[41]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[43]||(s[43]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">recover_maximal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Recover all frequent itemsets from a DataFrame of maximal frequent itemsets.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: A DataFrame containing the maximal frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the maximal frequent itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing all frequent itemsets, with columns: <ul><li><p><code>Itemset</code>: The items in the frequent itemset.</p></li><li><p><code>Length</code>: The number of items in the itemset.</p></li></ul></li></ul><p><strong>Description</strong></p><p>This function takes a DataFrame of maximal frequent itemsets and generates all possible subsets (including the maximal itemsets themselves) to recover the complete set of frequent itemsets. It does not calculate or recover support values, as these cannot be determined from maximal itemsets alone.</p><p>The function works as follows:</p><ol><li><p>For each maximal itemset, it generates all possible subsets.</p></li><li><p>It combines all these subsets into a single collection of frequent itemsets.</p></li><li><p>It removes any duplicate itemsets that might arise from overlapping maximal itemsets.</p></li><li><p>It returns the result as a DataFrame, sorted by itemset length in descending order.</p></li></ol><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find maximal frequent itemsets with minimum 5,000 transactions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maximal_sets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fpmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Recover frequent itemsets from the maximal itemsets</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">frequent_sets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> recover_maximal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maximal_sets)</span></span></code></pre></div>`,12)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[42]||(s[42]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/itemsets/frequent/recovery.jl#L121-L158",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[42]})]),s[67]||(s[67]=i("h2",{id:"Data-Structures",tabindex:"-1"},[e("Data Structures "),i("a",{class:"header-anchor",href:"#Data-Structures","aria-label":'Permalink to "Data Structures {#Data-Structures}"'},"​")],-1)),s[68]||(s[68]=i("h3",{id:"Transactions-Objects",tabindex:"-1"},[i("code",null,"Transactions"),e(" Objects "),i("a",{class:"header-anchor",href:"#Transactions-Objects","aria-label":'Permalink to "`Transactions` Objects {#Transactions-Objects}"'},"​")],-1)),i("details",A,[i("summary",null,[s[44]||(s[44]=i("a",{id:"RuleMiner.Txns",href:"#RuleMiner.Txns"},[i("span",{class:"jlbinding"},"RuleMiner.Txns")],-1)),s[45]||(s[45]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[47]||(s[47]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Transactions</span></span></code></pre></div><p>A struct representing a collection of transactions in a sparse matrix format.</p><p><strong>Fields</strong></p><ul><li><p><code>matrix::SparseMatrixCSC{Bool,Int64}</code>: A sparse boolean matrix representing the transactions. Rows correspond to transactions, columns to items. A <code>true</code> value at position (i,j) indicates that the item j is present in transaction i.</p></li><li><p><code>colkeys::Vector{String}</code>: A vector of item names corresponding to matrix columns.</p></li><li><p><code>linekeys::Vector{String}</code>: A vector of transaction identifiers corresponding to matrix rows.</p></li><li><p><code>n_transactions::Int</code>: The total number of transactions in the dataset.</p></li></ul><p><strong>Description</strong></p><p>The <code>Txns</code> struct provides an efficient representation of transaction data, particularly useful for large datasets in market basket analysis, association rule mining, or similar applications where memory efficiency is crucial.</p><p>The sparse matrix representation allows for efficient storage and computation, especially when dealing with datasets where each transaction contains only a small subset of all possible items.</p><p><strong>Constructors</strong></p><p><strong>Default Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(matrix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SparseMatrixCSC{Bool,Int64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, colkeys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, linekeys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>DataFrame Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, indexcol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Symbol,Nothing}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The DataFrame constructor allows direct creation of a <code>Txns</code> object from a DataFrame:</p><ul><li><p><code>df</code>: Input DataFrame where each row is a transaction and each column is an item.</p></li><li><p><code>indexcol</code>: Optional. Specifies a column to use as transaction identifiers. If not provided, row numbers are used as identifiers.</p></li></ul><p><strong>File Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, delimiter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Char,String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; id_col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, skiplines</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nlines</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The file constructor allows creation of a <code>Txns</code> object directly from a file:</p><ul><li><p><code>file</code>: Path to the input file containing transaction data.</p></li><li><p><code>delimiter</code>: Character or string used to separate items in each transaction.</p></li></ul><p>Keyword Arguments:</p><ul><li><p><code>id_col</code>: If true, treats the first item in each line as a transaction identifier.</p></li><li><p><code>skiplines</code>: Number of lines to skip at the beginning of the file (e.g., for headers).</p></li><li><p><code>nlines</code>: Maximum number of lines to read. If 0, reads the entire file.</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create from existing data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">matrix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SparseMatrixCSC{Bool,Int64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">colkeys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;apple&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;banana&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orange&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">linekeys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T001&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T002&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T003&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(matrix, colkeys, linekeys)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create from DataFrame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;T3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Apple </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Banana </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Orange </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns_from_df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df, indexcol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:ID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create from file with character delimiter</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns_from_file_char </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;,&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id_col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, skiplines</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create from file with string delimiter</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns_from_file_string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;||&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id_col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, skiplines</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Access data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item_in_transaction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">matrix[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Check if item 1 is in transaction 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">colkeys[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get the name of item 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transaction_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">linekeys[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get the ID of transaction 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">total_transactions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n_transactions </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get the total number of transactions</span></span></code></pre></div>`,22)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[46]||(s[46]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/data_structures/txns.jl#L6-L83",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[46]})]),s[69]||(s[69]=i("h3",{id:"FP-Mining-Objects",tabindex:"-1"},[e("FP Mining Objects "),i("a",{class:"header-anchor",href:"#FP-Mining-Objects","aria-label":'Permalink to "FP Mining Objects {#FP-Mining-Objects}"'},"​")],-1)),i("details",D,[i("summary",null,[s[48]||(s[48]=i("a",{id:"RuleMiner.FPTree",href:"#RuleMiner.FPTree"},[i("span",{class:"jlbinding"},"RuleMiner.FPTree")],-1)),s[49]||(s[49]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[51]||(s[51]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FPTree</span></span></code></pre></div><p>A struct representing an FP-Tree (Frequent Pattern Tree) structure, used for efficient frequent itemset mining.</p><p><strong>Fields</strong></p><ul><li><p><code>root::FPNode</code>: The root node of the FP-Tree.</p></li><li><p><code>header_table::Dict{Int, Vector{FPNode}}</code>: A dictionary where keys are item indices and values are vectors of FPNodes representing the item occurrences in the tree.</p></li><li><p><code>col_mapping::Dict{Int, Int}</code>: A dictionary mapping the condensed item indices to the original item indices.</p></li><li><p><code>min_support::Int</code>: The minimum support threshold used to construct the tree.</p></li><li><p><code>n_transactions::Int</code>: The total number of transactions used to build the tree.</p></li><li><p><code>colkeys::Vector{String}</code>: The original item names corresponding to the column indices.</p></li></ul><p><strong>Description</strong></p><p>The FP-Tree is a compact representation of transaction data, designed for efficient frequent pattern mining. It stores frequent items in a tree structure, with shared prefixes allowing for memory-efficient storage and fast traversal.</p><p>The tree construction process involves:</p><ol><li><p>Counting item frequencies and filtering out infrequent items.</p></li><li><p>Sorting items by frequency.</p></li><li><p>Inserting transactions into the tree, with items ordered by their frequency.</p></li></ol><p>The <code>header_table</code> provides quick access to all occurrences of an item in the tree, facilitating efficient mining operations.</p><p><strong>Constructors</strong></p><p><strong>Default Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p><strong>Transaction Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Transactions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_support</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Int,Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The Transaction constructor allows creation of a <code>FPTree</code> object from a <code>Transactions</code>-type object:</p><ul><li><p><code>txns</code>: Transactions object to convert</p></li><li><p><code>min_support</code>: Minimum support for an item to be included int the tree</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create an empty FP-Tree</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">empty_tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create an FP-Tree from a Transactions object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">txns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;transactions.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using 5% minimum support</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Access tree properties</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Minimum support: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">min_support)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Number of transactions: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n_transactions)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Number of unique items: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">header_table))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Traverse the tree (example)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, prefix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{String}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String[])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prefix, tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">colkeys[node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value]), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; -&gt; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">children)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prefix, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">colkeys[node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String[]))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root)</span></span></code></pre></div><p><strong>Notes</strong></p><ul><li><p>The FP-Tree structure is particularly useful for algorithms like FP-Growth, FP-Close, and FP-Max.</p></li><li><p>When constructing from a Transactions object, items not meeting the minimum support threshold are excluded from the tree.</p></li><li><p>The tree construction process is parallelized for efficiency on multi-core systems.</p></li></ul><p><strong>References</strong></p><p>Han, J., Pei, J., &amp; Yin, Y. (2000). Mining Frequent Patterns without Candidate Generation. In proceedings of the 2000 ACM SIGMOD International Conference on Management of Data (pp. 1-12).</p>`,22)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[50]||(s[50]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/data_structures/fptree.jl#L6-L78",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[50]})]),i("details",T,[i("summary",null,[s[52]||(s[52]=i("a",{id:"RuleMiner.FPNode",href:"#RuleMiner.FPNode"},[i("span",{class:"jlbinding"},"RuleMiner.FPNode")],-1)),s[53]||(s[53]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[55]||(s[55]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FPNode</span></span></code></pre></div><p>A mutable struct representing a node in an FP-tree (Frequent Pattern Tree) structure.</p><p><strong>Fields</strong></p><ul><li><p><code>value::Int</code>: The item index this node represents. For the root node, this is typically -1.</p></li><li><p><code>support::Int</code>: The number of transactions that contain this item in the path from the root to this node.</p></li><li><p><code>children::Dict{Int, FPNode}</code>: A dictionary of child nodes, where keys are item indices and values are <code>FPNode</code> objects.</p></li><li><p><code>parent::Union{FPNode, Nothing}</code>: The parent node in the FP-tree. For the root node, this is <code>nothing</code>.</p></li></ul><p><strong>Description</strong></p><p><code>FPNode</code> is the fundamental building block of an FP-tree. Each node represents an item in the dataset and keeps track of how many transactions contain the path from the root to this item. The tree structure allows for efficient mining of frequent patterns without repeated database scans.</p><p>The <code>children</code> dictionary allows for quick access to child nodes, facilitating efficient tree traversal. The <code>parent</code> reference enables bottom-up traversal, which is crucial for some frequent pattern mining algorithms.</p><p><strong>Constructor</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{FPNode, Nothing}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create a root node</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create child nodes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, root)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, root)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Add children to the root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Increase support of a node</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">support </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create a grandchild node</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">grandchild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, child1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grandchild</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Traverse the tree</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FPNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depth, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, Support: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">support)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">children)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, depth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print_tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root)</span></span></code></pre></div>`,11)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[54]||(s[54]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/data_structures/fpnode.jl#L6-L60",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[54]})]),s[70]||(s[70]=i("h2",{id:"Utility-Functions",tabindex:"-1"},[e("Utility Functions "),i("a",{class:"header-anchor",href:"#Utility-Functions","aria-label":'Permalink to "Utility Functions {#Utility-Functions}"'},"​")],-1)),i("details",x,[i("summary",null,[s[56]||(s[56]=i("a",{id:"RuleMiner.txns_to_df-Tuple{Txns}",href:"#RuleMiner.txns_to_df-Tuple{Txns}"},[i("span",{class:"jlbinding"},"RuleMiner.txns_to_df")],-1)),s[57]||(s[57]=e()),a(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[59]||(s[59]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">txns_to_df</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Txns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id_col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span></code></pre></div><p>Convert a Txns object into a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>txns::Txns</code>: The Txns object to be converted.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame representation of the transactions.</li></ul><p><strong>Description</strong></p><p>This function converts a Txns object, which uses a sparse matrix representation, into a DataFrame. Each row of the resulting DataFrame represents a transaction, and each column represents an item.</p><p>The values in the DataFrame are integers, where 1 indicates the presence of an item in a transaction, and 0 indicates its absence.</p><p><strong>Features</strong></p><ul><li><p>Preserves the original item names as column names.</p></li><li><p>Optionally includes an &#39;Index&#39; column with the original transaction identifiers.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Assuming &#39;txns&#39; is a pre-existing Txns object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> txns_to_df</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(txns, id_col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,13)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>s[58]||(s[58]=[i("a",{href:"https://github.com/JaredSchwartz/RuleMiner.jl/blob/271659de083cac90ed62f7642f05d2882b827151/src/utils/txn_utils.jl#L210-L238",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[58]})])])}const w=p(o,[["render",v]]);export{P as __pageData,w as default};
